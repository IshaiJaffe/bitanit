// Generated by CoffeeScript 1.4.0
(function() {

  this.WorkOrders = new Meteor.Collection('workorders');
 
 
   var Stages = this.WorkOrders.Stages = {
		FLOOR:{
			label:'רצפה'
		},
		BASEMENT:{
			label:'מרתף'
		},
		WALLS:{
			label:'קירות'
		},
		CEILING:{
			label:'תקרה'
		},
		CONCRETE_A:{
			label:'בטון א\'',
			external:true,
			dependencies:['FLOOR','BASEMENT','WALLS','CEILING']
		},
		CONCRETE_B:{
			label:'בטון ב\'',
			external:true,
			dependencies:['CONCRETE_A']
		},
		SEALING:{
			label:'איטום',
			dependencies:['FLOOR','BASEMENT','WALLS','CEILING']
		},
		FLOODING:{
			label:'הצפה',
			external:true,
			dependencies:['SEALING']
		},
		FINISHING:{
			label:'גימור',
			dependencies:['SEALING']
		},
		DONE:{
			label:'מוכן',
			dependencies:['FINISHING']
		},
		ACCESORIES:{
			label:'אביזרים',
			dependencies:['DONE']
		}		
   };

 
  var WorkOrderStage = new SimpleSchema({
		name:{
			type:String,	
			label:'שם',
			optional:false,			
			allowedValues:Object.keys(Stages)
		},
		approved:{
			type:Boolean,				
			defaultValue:false
		},
		date:{
			type:Date,
			optional:true
		},
		by:{
		  type: String,
		  label:'נשלח ע"י',
		  regEx: SimpleSchema.RegEx.Id,
		  optional: true,
		  autoform: {
			options: function() {
			  return _.map(Meteor.users.find().fetch(), function(user) {
				return {
				  label: user.emails[0].username,
				  value: user._id
				};
			  });
			}
		  }
		},
		signature:{
			type: String,
			  label:'תמונה',
			  optional:true,
			  autoform: {
				afFieldInput: {
				  type: 'fileUpload',
				  collection: 'Attachments'
				}
			  }
		}
	});

  Schemas.WorkOrders = new SimpleSchema({
    id: {
      type: Number,
      decimal: false,
	  unique: true,
	  label:'מספר הזמנה',
	  autoValue: function() {
        if (!this.isInsert) 
		   return;
		return getAutoMac('WorkOrders','id');
      }
    },
	customer:{
	  type: String,
	  regEx: SimpleSchema.RegEx.Id,
	  label:'לקוח',
	  autoform: {
		options: function() {
		  return _.map(Customers.find().fetch(), function(customer) {
			return {
			  label: customer.name,
			  value: customer._id
			};
		  });
		}
	  }
	},
	room:{
	  type: String,
	  regEx: SimpleSchema.RegEx.Id,
	  label:'חדר',
	  autoform: {
		options: function() {
		  return _.map(Rooms.find().fetch(), function(rooms) {
			return {
			  label: rooms.name,
			  value: rooms._id
			};
		  });
		}
	  }
	},
    orderDate: {
      type: Date,
	  label:'תאריך הזמנה',
      autoValue: function() {
        if (this.isInsert) {
          return new Date();
        }
      }
    },
    deadline: {
      type: Date,
      optional: true,
	  label:'תאריך מתוכנן',
      autoValue: function() {
        if (this.isInsert) {
          return new Date(Date.now() + 1000*60*60*24*30);
        }
      }
    },
	deliveryDate: {
      type: Date,
      optional: true,
	  label:'תאריך משלוח',      
    },    
    creator: {
      type: String,
	  label:'נקלט ע"י',
      regEx: SimpleSchema.RegEx.Id,
      autoValue: function() {
        if (this.isInsert) {
          return Meteor.userId();
        }
      },
      autoform: {
        options: function() {
          return _.map(Meteor.users.find().fetch(), function(user) {
            return {
              label: user.emails[0].username,
              value: user._id
            };
          });
        }
      }
    },
	stages:{
		type:[WorkOrderStage]
	},
	
	closedBy: {
      type: String,
	  label:'נשלח ע"י',
      regEx: SimpleSchema.RegEx.Id,
	  optional: true,
      autoform: {
        options: function() {
          return _.map(Meteor.users.find().fetch(), function(user) {
            return {
              label: user.emails[0].username,
              value: user._id
            };
          });
        }
      }
    }
  });

  WorkOrders.attachSchema(Schemas.WorkOrders);

  WorkOrders.after.findOne(function(a,b,c,doc) { 
	if(!doc)
		return;
	if(!doc.stages)
		doc.stages = [];
    var stages = _.indexBy(doc.stages,'name');
	for(var stage in Stages){
		if(!stages[stage]){
			doc.stages.push({name:stage,approved:false});
		}
	}
  });
  WorkOrders.canSignStage = function(workOrder,stage){
      var uncompleted = (Stages[stage].dependencies || [])
	  .filter(function(stageName) { 
	     var orderStageStatus = _.find(workOrder.stages,function(s) { return s.name == stageName; });
		return !orderStageStatus.approved;
	  })
	  .map(function(stageName) {
		return Stages[stageName].label;
	  });
	  if(!uncompleted.length)
		return true;
	  return uncompleted.join(', ');
	};
}).call(this);
